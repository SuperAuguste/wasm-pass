// Generated by wasm-pass; edit at your own risk!

const util = require("util");

/**
 * @template T
 * @param {T} EnumType
 * @param {number} value
 * @returns {T}
 */
function createEnumValue(EnumType, value) {
    const lit = new EnumType();
    lit.value = value;
    return lit;
}

/**
 * @param {Object|Function} value
 * @returns {number}
 */
function sizeOf(value) {
    if (typeof value === "object" || typeof value === "function") {
        return value.__size;
    }

    throw new Error("Value has unknown size!");
}

class Enum {
    /** @type {number} */
    value;

    constructor() {
        if (arguments.length !== 0) throw new Error(`Use ${this.constructor.name}.from(number)!`);
    }

    /** @param {number} value */
    static from(value) {
        for (const tag of Object.values(this.values)) {
            if (tag.value === value) return tag;
        }

        const val = new this();
        val.value = value;
        return val;
    }

    toString() {
        for (const [name, tag] of Object.entries(this.constructor.values)) {
            if (tag.value === this.value) return `${this.constructor.name}.${name}`;
        }

        return `${this.constructor.name}(${this.value})`;
    }

    [util.inspect.custom]() {
        return this.toString();
    }
}

class Struct {}

class Slice {
    /** @type {Object} */
    type;

    /** @type {number} */
    len;

    /** @type {number} */
    ptr;

    constructor(type, len, ptr) {
        this.type = type;
        this.len = len;
        this.ptr = ptr;
    }

    /**
     * Decodes a `Slice`
     * @param {Object} type Type of slice items
     * @param {DataView} dataView DataView representing WASM memory
     * @param {number} offset The offset at which the struct starts
     * @returns {Slice}
     */
    static decode(type, dataView, offset = 0) {
        const len = dataView.getUint32(offset);
        const ptr = dataView.getUint32(offset + 4);

        return new this(type, len, ptr);
    }

    /**
     * @param {DataView} view
     * @param {number} index
     * @returns {any}
     */
    get(view, index) {
        return this.type.decode(view, this.ptr + index * sizeOf(this.type));
    }

    /**
     * @param {DataView} view
     * @param {number} index
     * @param {any} value
     */
    set(view, index, value) {
        value.encode(view, this.ptr + index * sizeOf(this.type));
    }
}

class Allocator {
    allocBytes;
    freeBytes;

    /** @param {WebAssembly.Exports} exports */
    constructor(exports) {
        this.allocBytes = exports.allocBytes;
        this.freeBytes = exports.freeBytes;
    }

    /**
     * @param {Object} type
     * @param {number} len
     * @returns {Slice}
     */
    alloc(type, len) {
        // @ts-ignore
        return new Slice(type, len, this.allocBytes(sizeOf(type) * len));
    }

    /** @param {Slice} slice */
    free(slice) {
        // @ts-ignore
        this.freeBytes(slice.ptr, sizeOf(slice.type) * slice.len);
    }
}

/** @param {WebAssembly.Instance} instance */
module.exports = function bind(instance) {
    let view = new DataView(instance.exports.memory.buffer);

    function getDataView() {
        // When dataView.buffer.byteLength is 0, the memory buffer was resized and needs to be refereshed.
        return dataView.buffer.byteLength === 0 ? (view = new DataView(instance.exports.memory.buffer)) : view;
    }

    /// BINDINGS
    return bindings;
};

module.exports.Allocator = Allocator;
module.exports.Struct = Struct;
module.exports.sizeOf = sizeOf;
module.exports.Slice = Slice;
module.exports.Enum = Enum;
